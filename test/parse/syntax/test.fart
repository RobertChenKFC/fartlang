import std.dbg.Dbg.*;

class Array {
    const u64 DEFUALT_CAPACITY = 1;
    any[] _arr;
    u64 _size, _capacity;

    Array() {
        _arr = new any[DEFAULT_CAPACITY];
        _size = 0;
        _capacity = DEFAULT_CAPACITY;
    }

    any get(u64 i) {
        assert(0 <= i < _size);
        return _arr[i];
    }

    void set(u64 i, any val) {
        assert(0 <= i < _size);
        _arr[i] = val;
    }

    void push(any val) {
        if _size == _capacity {
            _capacity *= 2;
            var arr = new any[_capacity];
            for var i = 0; i < _size; ++i {
                arr[i] = _arr[i];
            }
            _arr = arr;
        }
        arr[_size] = val;
        ++_size;
    }

    any pop() {
        assert(_size > 0);
        --_size;
        return _arr[_size];
    }

    u64 size() {
        return _size;
    }

    void clear() {
        _size = 0;
    }
}

class Algorithm {
    type LessThan = bool(any, any);

    static void sort(Array arr, LessThan lt) {
        var buf = Array();
        _sort(arr, 0, arr.size(), buf, lt);
    }

    static void _sort(Array arr, u64 from, u64 to, Array buf, LessThan lt) {
        ##
        Classic merge sort implementation:

        Recursive and not in-place; buffer is allocated by caller
        ##

        # Edge case
        if from + 1 == to {
            return;
        }

        # Recursive calls
        u64 mid = from + (to - from) / 2;
        _sort(from, mid);
        _sort(mid, to);

        # Merge two partitions to buf
        u64 i = from, j = mid;
        buf.clear();
        while i < mid and j < to {
            if lt(arr.get(i), arr.get(j)) {
                buf.push(arr.get(i));
                ++i;
            } else {
                buf.push(arr.get(j));
            }
        }
        while i < mid {
            buf.push(arr.get(i));
            ++i;
        }
        while j < mid {
            buf.push(arr.get(j));
            ++j;
        }

        # Copy buf to arr
        for i = 0; i < buf.size(); ++i {
            arr.set(from + i, buf.get(i));
        }
    }
}

class String {
    const u64 DEFAULT_CAPACITY = 8;
    u8[] _arr;
    u64 _size, _capacity;

    String() {
        _arr = new u8[DEFAULT_CAPACITY];
        _arr[0] = '\0';
        _size = 1;
        _capacity = DEFAULT_CAPACITY;
    }

    void push(u8 char) {
        _arr[_size - 1] = char;
        if _size == _capacity {
            _capacity *= 2;
            var arr = new u8[_capacity];
            for var i = 0; i < _size; ++i {
                arr[i] = _arr[i];
            }
            _arr = arr;
        }
        _arr[_size] = '\0';
        ++_size;
    }

	u64 length() {
		return _size;
	} 

	u64 toUnsigned() {
		return StringView(_arr).toUnsigned();
	}

	u8 get(u64 i) {
		assert(0 <= i < _size);
		return _arr[i];
	}

	StringView view(u64 l, u64 r) {
		assert(0 <= l <= r <= _size);
		return StringView(_arr, l, r);
	}
}

class StringView {
	u8[] _arr;
	u64 _l, _r;

	static StringView(u8[] arr) {
		u64 len = 0;
		for ; arr[len] != '\0'; ++len {}
		return StringView(arr, 0, len);
	}

	StringView(u8[] arr, u64 l, u64 r) {
		_arr = arr;
		_l = l;
		_r = r;
	}

	u64 length() {
		return _size;
	}

	u64 toUnsigned() {
		u64 unsigned = 0;
		for var i = _l; i < _r; ++i {
			assert('0' <= _arr[i] <= '9');
			unsigned = unsigned * 10 + _arr[i] - '0';
		}
		return unsigned;
	}
}

class Utility {
    u64 getExactFileSize(String fileSize) {
		var len = fileSize.length();
		assert(len >= 3);
		assert(fileSize.get(len - 1) == 'B');
		var digitsLen = len - 3 if fileSize.get(len - 2) == 'i' else len - 2;
		var exactSize = fileSize.view(0, digitsLen).toUnsigned();
		switch fileSize[len - 3] {
			case 'T' {
				exactSize *= 1e12;
			}
			case 'G' {
				exactSize *= 1e9;
			}
			case 'M' {
				exactSize *= 1e6;
			}
			case 'K' {
				exactSize *= 1e3;
			}
		}
		return exactSize;
    }
}
